<?xml version="1.0" encoding="UTF-8"?>
<interview_presentation>
    <metadata>
        <candidato>Cezi Cola â€” Senior Software Engineer</candidato>
        <vaga>Senior Software Engineer Principal</vaga>
        <tempo_apresentacao>30 minutos</tempo_apresentacao>
        <projeto>https://github.com/cezicolaseniorsoftwareengineer/payvorax</projeto>
        <demo_ao_vivo>https://new-credit-fintech.onrender.com</demo_ao_vivo>
        <data_documento>Novembro 2025</data_documento>
    </metadata>

    <resumo_analise>
        <titulo>Resumo da Analise do Sistema PayvoraX</titulo>
        <pontos_positivos>
            <ponto categoria="Arquitetura Enterprise-Grade">
                <item>DDD + Hexagonal Architecture documentada em ADR</item>
                <item>Separacao clara entre dominio, aplicacao e infraestrutura</item>
                <item>Cada modulo segue o padrao: models.py, schemas.py, service.py, router.py</item>
            </ponto>
            <ponto categoria="Seguranca em Multiplas Camadas">
                <item>Argon2 para hashing de senhas (superior ao bcrypt)</item>
                <item>JWT com cookies HttpOnly + Secure + SameSite</item>
                <item>Headers HTTP de seguranca (HSTS, X-Frame-Options, XSS Protection)</item>
                <item>Mascaramento de dados sensiveis em logs</item>
                <item>Validacao Pydantic em todas as fronteiras</item>
            </ponto>
            <ponto categoria="Engine Anti-Fraude Configuravel">
                <item>Scoring de 0-100 com regras extensiveis (Strategy Pattern)</item>
                <item>Decisao automatica baseada em threshold</item>
                <item>Regras: horario noturno, valor alto, tentativas excessivas</item>
            </ponto>
            <ponto categoria="Idempotencia Garantida no PIX">
                <item>Header obrigatorio X-Idempotency-Key</item>
                <item>Previne debitos duplicados por design</item>
            </ponto>
            <ponto categoria="Observabilidade Completa">
                <item>Correlation IDs propagados em todas as requisicoes</item>
                <item>Structured logging com formato consistente</item>
                <item>Funcao audit_log() para compliance</item>
                <item>Header X-Process-Time para metricas</item>
            </ponto>
            <ponto categoria="CI/CD Profissional">
                <item>Pipeline GitHub Actions com lint, security scan, testes</item>
                <item>Deploy automatizado no Render.com</item>
                <item>Docker multi-stage pronto para producao</item>
            </ponto>
            <ponto categoria="Cobertura de Testes">
                <item>24+ testes automatizados</item>
                <item>Testes data-driven com pytest.mark.parametrize</item>
                <item>Cobertura minima de 70% enforced no CI</item>
            </ponto>
        </pontos_positivos>
        <estrutura_roteiro>
            <secao tempo="2 min">Sumario executivo</secao>
            <secao tempo="8 min">Arquitetura e decisoes tecnicas</secao>
            <secao tempo="7 min">Seguranca</secao>
            <secao tempo="5 min">Diferenciais tecnicos</secao>
            <secao tempo="5 min">Demonstracao ao vivo com curls prontos</secao>
            <secao tempo="3 min">Perguntas frequentes</secao>
        </estrutura_roteiro>
    </resumo_analise>

    <sumario_executivo tempo="2 minutos">
        <titulo>O Que E Este Sistema</titulo>
        <descricao>Uma plataforma RegTech enterprise-grade para operacoes financeiras</descricao>
        <funcionalidades>
            <funcionalidade>PIX com idempotencia garantida e rastreabilidade completa</funcionalidade>
            <funcionalidade>Simulacao de Parcelamento com calculo CET e tabela Price</funcionalidade>
            <funcionalidade>Engine Anti-Fraude em tempo real com scoring configuravel</funcionalidade>
            <funcionalidade>Gestao de Cartoes virtuais e fisicos</funcionalidade>
            <funcionalidade>Pagamento de Boletos com validacao de codigo de barras</funcionalidade>
        </funcionalidades>
        <metricas>
            <metrica nome="Commits">36+</metrica>
            <metrica nome="Testes Automatizados">24+</metrica>
            <metrica nome="Cobertura de Codigo">70%+</metrica>
            <metrica nome="Endpoints REST">15+</metrica>
            <metrica nome="Dominios Implementados">6</metrica>
            <metrica nome="Deploy Automatizado">Render.com</metrica>
            <metrica nome="Pipeline CI/CD">GitHub Actions</metrica>
        </metricas>
    </sumario_executivo>

    <parte1_arquitetura tempo="8 minutos">
        <titulo>ARQUITETURA E DECISOES TECNICAS</titulo>

        <secao1_1>
            <titulo>Padrao Arquitetural: DDD + Hexagonal</titulo>
            <documentacao>docs/adr/001-hexagonal-architecture.md</documentacao>
            <justificativas>
                <justificativa>Dominio Isolado: Regras de negocio financeiras nao dependem de FastAPI, SQLAlchemy ou qualquer framework</justificativa>
                <justificativa>Testabilidade: Posso testar logica de negocio sem mockar HTTP ou banco de dados</justificativa>
                <justificativa>Flexibilidade: Trocar SQLite por PostgreSQL ou FastAPI por Flask sem tocar nas regras de negocio</justificativa>
                <justificativa>Compliance: Facilita auditoria pois a logica de dominio esta separada da infraestrutura</justificativa>
            </justificativas>
            <estrutura_dominio>
                <arquivo camada="Infrastructure Layer">models.py - Entidades SQLAlchemy</arquivo>
                <arquivo camada="Application Layer">schemas.py - Validacao Pydantic</arquivo>
                <arquivo camada="Domain Layer">service.py - Logica de Negocio</arquivo>
                <arquivo camada="Primary Adapter">router.py - Endpoints HTTP</arquivo>
            </estrutura_dominio>
        </secao1_1>

        <secao1_2>
            <titulo>Principios SOLID Aplicados</titulo>
            <principios>
                <principio nome="Single Responsibility">Cada modulo tem uma unica responsabilidade (pix/, boleto/, cards/)</principio>
                <principio nome="Open/Closed">Engine Anti-Fraude extensivel via novas regras sem modificar codigo existente</principio>
                <principio nome="Liskov Substitution">Regras de antifraude herdam de AntifraudRule e sao intercambiaveis</principio>
                <principio nome="Interface Segregation">Schemas Pydantic separados para Request e Response</principio>
                <principio nome="Dependency Inversion">Services dependem de abstracoes, nao de implementacoes concretas</principio>
            </principios>
        </secao1_2>

        <secao1_3>
            <titulo>Observabilidade desde o Dia 1</titulo>
            <exemplo_log>2025-11-19 10:30:15 | INFO | fintech | corr-123-456 | PIX created: id=abc, value=150.0</exemplo_log>
            <componentes>
                <componente>Correlation IDs: Propagados em todas as requisicoes via header X-Correlation-ID</componente>
                <componente>Structured Logging: Formato consistente com contexto de negocio</componente>
                <componente>Audit Log: Funcao dedicada audit_log() para operacoes financeiras</componente>
                <componente>Metricas de Performance: Header X-Process-Time em cada resposta</componente>
            </componentes>
        </secao1_3>
    </parte1_arquitetura>

    <parte2_seguranca tempo="7 minutos">
        <titulo>SEGURANCA</titulo>

        <secao2_1>
            <titulo>Defense in Depth (Multiplas Camadas)</titulo>
            <camadas>
                <camada nivel="1" nome="HTTP Headers">HSTS, X-Frame-Options, XSS</camada>
                <camada nivel="2" nome="Autenticacao">JWT (HS256), HttpOnly Cookies</camada>
                <camada nivel="3" nome="Input Validation">Pydantic em TODAS as fronteiras</camada>
                <camada nivel="4" nome="Anti-Fraude">Scoring em tempo real (0-100)</camada>
                <camada nivel="5" nome="Criptografia">Argon2 (senhas), Masking (logs)</camada>
            </camadas>
        </secao2_1>

        <secao2_2>
            <titulo>Implementacoes Especificas</titulo>
            <implementacao area="Autenticacao (app/auth/)">
                <descricao>Argon2 para hashing de senhas (mais seguro que bcrypt)</descricao>
                <codigo><![CDATA[
pwd_context = CryptContext(schemes=["argon2"], deprecated="auto")

response.set_cookie(
    key="access_token",
    value=f"Bearer {access_token}",
    httponly=True,      # JS nao consegue acessar
    secure=True,        # Apenas HTTPS
    samesite="lax"      # Protecao CSRF
)
                ]]></codigo>
            </implementacao>
            <implementacao area="Validacao de Inputs (app/pix/schemas.py)">
                <descricao>Validacao rigorosa de chave PIX por tipo</descricao>
                <codigo><![CDATA[
@field_validator('pix_key')
def validate_pix_key(cls, v: str, info: ValidationInfo) -> str:
    if tipo == PixKeyType.CPF:
        cpf = re.sub(r'\D', '', v)
        if len(cpf) != 11:
            raise ValueError('CPF deve ter 11 digitos')
                ]]></codigo>
            </implementacao>
            <implementacao area="Mascaramento de Dados (app/core/security.py)">
                <descricao>Sanitizacao de dados sensiveis em logs</descricao>
                <codigo><![CDATA[
def mask_sensitive_data(value: str, visible_chars: int = 4) -> str:
    # "12345678901" -> "*******8901"
    return "*" * (len(value) - visible_chars) + value[-visible_chars:]
                ]]></codigo>
            </implementacao>
            <implementacao area="Headers HTTP (app/main.py)">
                <descricao>Headers de seguranca em todas as respostas</descricao>
                <codigo><![CDATA[
response.headers["Strict-Transport-Security"] = "max-age=31536000"
response.headers["X-Frame-Options"] = "DENY"
response.headers["X-Content-Type-Options"] = "nosniff"
response.headers["X-XSS-Protection"] = "1; mode=block"
                ]]></codigo>
            </implementacao>
        </secao2_2>

        <secao2_3>
            <titulo>Engine Anti-Fraude</titulo>
            <regras>
                <regra nome="NIGHT_TIME" pontos="40">Transacao entre 22h e 06h</regra>
                <regra nome="HIGH_VALUE" pontos="30">Valor acima de R$ 300</regra>
                <regra nome="EXCESSIVE_ATTEMPTS" pontos="50">Mais de 3 tentativas em 24h</regra>
                <regra nome="EXTREME_VALUE" pontos="60">Valor acima de R$ 1.000</regra>
            </regras>
            <logica_aprovacao>
                <aprovado>Score menor que 60</aprovado>
                <rejeitado>Score maior ou igual a 60</rejeitado>
            </logica_aprovacao>
            <exemplo_analise><![CDATA[
{
  "score": 90,
  "approved": false,
  "risk_level": "HIGH",
  "triggered_rules": [
    "NIGHT_TIME: Transacao em horario de risco",
    "HIGH_VALUE: Valor acima de R$ 300",
    "EXCESSIVE_ATTEMPTS: Mais de 3 tentativas"
  ],
  "recommendation": "Rejeitar e notificar usuario"
}
            ]]></exemplo_analise>
        </secao2_3>
    </parte2_seguranca>

    <parte3_diferenciais tempo="5 minutos">
        <titulo>DIFERENCIAIS TECNICOS</titulo>

        <secao3_1>
            <titulo>Idempotencia Garantida (PIX)</titulo>
            <problema>Em sistemas de pagamento, requisicoes duplicadas podem causar debitos duplos</problema>
            <solucao>
                <descricao>Header obrigatorio em toda transacao PIX</descricao>
                <codigo><![CDATA[
X-Idempotency-Key: unique-key-123

existing_pix = db.query(PixTransaction).filter(
    PixTransaction.idempotency_key == idempotency_key
).first()

if existing_pix:
    return existing_pix
                ]]></codigo>
            </solucao>
            <teste><![CDATA[
def test_pix_idempotency():
    """Mesma key = mesma transacao"""
    pix1 = create_pix(db, data, "idem-key-123", ...)
    pix2 = create_pix(db, data, "idem-key-123", ...)
    assert pix1.id == pix2.id  # PASSA
            ]]></teste>
        </secao3_1>

        <secao3_2>
            <titulo>Calculo CET (Custo Efetivo Total)</titulo>
            <requisito>BCB exige que fintechs informem o CET anualizado</requisito>
            <formula>
                <price>PMT = PV * [i * (1+i)^n] / [(1+i)^n - 1]</price>
                <cet_anual>((1 + taxa_mensal)^12 - 1) * 100</cet_anual>
            </formula>
            <exemplo_resposta><![CDATA[
{
  "installment": 91.62,
  "total_paid": 1099.44,
  "annual_cet": 51.11,
  "table": [
    {"month": 1, "payment": 91.62, "interest": 35.0, "principal": 56.62, "balance": 943.38},
    {"month": 2, "payment": 91.62, "interest": 33.02, "principal": 58.6, "balance": 884.78}
  ]
}
            ]]></exemplo_resposta>
        </secao3_2>

        <secao3_3>
            <titulo>Transacoes Internas em Tempo Real (PIX)</titulo>
            <funcionalidade>Quando o destinatario e um usuario interno, o credito acontece instantaneamente</funcionalidade>
            <codigo><![CDATA[
if type == TransactionType.SENT and initial_status != PixStatus.SCHEDULED:
    recipient_user = db.query(User).filter(User.email == data.pix_key).first()
    if recipient_user:
        received_pix = PixTransaction(
            type=TransactionType.RECEIVED,
            status=PixStatus.CONFIRMED,
            user_id=recipient_user.id
        )
        db.add(received_pix)
            ]]></codigo>
        </secao3_3>

        <secao3_4>
            <titulo>Pipeline CI/CD Completo</titulo>
            <arquivo>.github/workflows/ci.yml</arquivo>
            <jobs>
                <job nome="quality-assurance">
                    <step>Linting (Flake8) - Qualidade de codigo</step>
                    <step>Security Scan (Bandit) - Vulnerabilidades</step>
                    <step>Dependency Audit - CVEs em dependencias</step>
                    <step>Run Tests (Pytest) - 70%+ cobertura</step>
                </job>
                <job nome="build-and-validate" depends_on="quality-assurance">
                    <step>Build Docker Image</step>
                    <step>Smoke Test (Container rodando)</step>
                </job>
            </jobs>
        </secao3_4>
    </parte3_diferenciais>

    <parte4_demonstracao tempo="5 minutos">
        <titulo>DEMONSTRACAO AO VIVO</titulo>
        <base_url>https://new-credit-fintech.onrender.com</base_url>

        <endpoints>
            <endpoint metodo="POST" path="/auth/register" funcao="Cadastro de usuario"/>
            <endpoint metodo="POST" path="/auth/login" funcao="Autenticacao"/>
            <endpoint metodo="POST" path="/pix/transacoes" funcao="Criar PIX"/>
            <endpoint metodo="GET" path="/pix/extrato" funcao="Extrato de transacoes"/>
            <endpoint metodo="POST" path="/parcelamento/simulate" funcao="Simular parcelamento"/>
            <endpoint metodo="POST" path="/antifraud/analyze" funcao="Analise anti-fraude"/>
            <endpoint metodo="POST" path="/cards/" funcao="Criar cartao"/>
            <endpoint metodo="GET" path="/cards/" funcao="Listar cartoes"/>
            <endpoint metodo="POST" path="/api/boleto/pay" funcao="Pagar boleto"/>
        </endpoints>

        <teste_idempotencia>
            <titulo>Teste de Idempotencia (curl)</titulo>
            <comando1><![CDATA[
curl -X POST https://payvorax.onrender.com/pix/transacoes \
  -H "X-Idempotency-Key: teste-123" \
  -H "Content-Type: application/json" \
  -d '{"value": 100, "pix_key": "user@test.com", "key_type": "EMAIL"}'
            ]]></comando1>
            <comando2><![CDATA[
curl -X POST https://payvorax.onrender.com/pix/transacoes \
  -H "X-Idempotency-Key: teste-123" \
  -H "Content-Type: application/json" \
  -d '{"value": 100, "pix_key": "user@test.com", "key_type": "EMAIL"}'
            ]]></comando2>
            <resultado_esperado>Ambas retornam o mesmo transaction_id</resultado_esperado>
        </teste_idempotencia>

        <teste_antifraude>
            <titulo>Teste de Anti-Fraude (curl)</titulo>
            <comando><![CDATA[
curl -X POST https://payvorax.onrender.com/antifraud/analyze \
  -H "Content-Type: application/json" \
  -d '{"value": 1500, "time": "23:30", "attempts_last_24h": 5}'
            ]]></comando>
            <resultado_esperado>score >= 60, approved: false, risk_level: HIGH</resultado_esperado>
        </teste_antifraude>

        <swagger_ui>
            <url>https://payvorax.onrender.com/docs</url>
            <recursos>
                <recurso>Documentacao interativa de todos os endpoints</recurso>
                <recurso>Teste direto no navegador</recurso>
                <recurso>Schemas de request/response visiveis</recurso>
            </recursos>
        </swagger_ui>
    </parte4_demonstracao>

    <parte5_perguntas_frequentes tempo="3 minutos">
        <titulo>PERGUNTAS FREQUENTES</titulo>

        <pergunta>
            <questao>Por que FastAPI e nao Django/Flask?</questao>
            <respostas>
                <resposta>Performance: ASGI async nativo, mais rapido que WSGI</resposta>
                <resposta>Typing: Validacao automatica via Pydantic integrada</resposta>
                <resposta>Documentacao: Swagger/OpenAPI gerado automaticamente</resposta>
                <resposta>Modernidade: Design para microservicos e APIs modernas</resposta>
            </respostas>
        </pergunta>

        <pergunta>
            <questao>Por que SQLite em producao?</questao>
            <respostas>
                <resposta>Fase MVP: Demonstra que a arquitetura suporta troca de banco sem refatoracao</resposta>
                <resposta>PostgreSQL Pronto: Basta trocar a connection string no .env</resposta>
                <resposta>Hexagonal: O dominio nao sabe qual banco esta sendo usado</resposta>
            </respostas>
        </pergunta>

        <pergunta>
            <questao>Como escalar este sistema?</questao>
            <respostas>
                <resposta>Database: Trocar SQLite por PostgreSQL (ja suportado)</resposta>
                <resposta>Cache: Adicionar Redis para sessoes e rate limiting</resposta>
                <resposta>Mensageria: Kafka/RabbitMQ para eventos assincronos</resposta>
                <resposta>Container: Kubernetes com HPA para autoscaling</resposta>
                <resposta>CDN: CloudFront/CloudFlare para assets estaticos</resposta>
            </respostas>
        </pergunta>

        <pergunta>
            <questao>E se o banco central exigir auditoria?</questao>
            <respostas>
                <resposta>Audit Log: Todas operacoes financeiras logadas via audit_log()</resposta>
                <resposta>Correlation IDs: Rastreabilidade ponta-a-ponta</resposta>
                <resposta>Imutabilidade: Transacoes nunca sao deletadas, apenas mudam de status</resposta>
                <resposta>Timestamps: Todos os registros tem created_at e updated_at com timezone</resposta>
            </respostas>
        </pergunta>
    </parte5_perguntas_frequentes>

    <conclusao>
        <titulo>CONCLUSAO</titulo>
        <demonstra>
            <item>Maturidade Tecnica: Arquitetura enterprise-grade com DDD + Hexagonal</item>
            <item>Foco em Seguranca: Defense in depth desde a autenticacao ate os logs</item>
            <item>Qualidade de Codigo: 24+ testes automatizados, CI/CD completo, 70%+ cobertura</item>
            <item>Pensamento Regulatorio: CET, audit logs, idempotencia - requisitos de compliance</item>
            <item>Deploy Profissional: Docker, GitHub Actions, Render.com com zero downtime</item>
        </demonstra>
        <roadmap>
            <item status="pendente">Rate Limiting com Redis</item>
            <item status="pendente">Integracao com PSP real (Mercado Pago, PagSeguro)</item>
            <item status="pendente">Metricas Prometheus + Grafana</item>
            <item status="pendente">Notificacoes via WebSocket</item>
            <item status="pendente">Autenticacao 2FA</item>
        </roadmap>
    </conclusao>

    <links>
        <repositorio>https://github.com/cezicolaseniorsoftwareengineer/payvorax</repositorio>
        <demo>https://payvorax.onrender.com</demo>
        <documentacao_api>https://payvorax.onrender.com/docs</documentacao_api>
    </links>
</interview_presentation>
